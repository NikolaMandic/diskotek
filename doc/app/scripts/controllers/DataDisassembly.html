<!DOCTYPE html><html lang="en"><head><title>app/scripts/controllers/DataDisassembly</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../"><meta name="groc-document-path" content="app/scripts/controllers/DataDisassembly"><meta name="groc-project-path" content="app/scripts/controllers/DataDisassembly.js"><link rel="stylesheet" type="text/css" media="all" href="../../../assets/style.css"><script type="text/javascript" src="../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">app/scripts/controllers/DataDisassembly.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>this is a disassembly module that contains state for disassembly of 
a target also contains commands for disassembling a target</p>

<p>it returns an object with following fields:<br/>
fileHeaders: contains elf header and program header<br/>
&nbsp; &nbsp; {<br/>
&nbsp; &nbsp;&nbsp; &nbsp;ehdr //elfheader<br/>
&nbsp; &nbsp; &nbsp; &nbsp;  phdr //program header<br/>
 &nbsp; &nbsp;  }<br/>
sectionHeaders: // this is array of section headers<br/>
&nbsp; &nbsp;[<br/>
&nbsp; &nbsp;&nbsp; &nbsp;//fields correspond to the output of objdump command<br/>
&nbsp; &nbsp;&nbsp; &nbsp;{ <br/>
 &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;name:, name of a section<br/>
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;size:,<br/>
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;VMA:,  //virtual mem addr<br/>
 &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;LMA:,  //load addr <br/>
 &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;fOff:, //file offset<br/>
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;align:,<br/>
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;flags:,       <br/>
 <br/>
 &nbsp; &nbsp;&nbsp; &nbsp; },<br/>
 &nbsp; &nbsp; &nbsp; &nbsp;{<br/>
 &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;    name<br/>
  &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;   ....<br/>
 &nbsp; &nbsp;&nbsp; &nbsp; },<br/>
&nbsp; &nbsp;]<br/></p></div></div><div class="code"><div class="wrapper"><span class="nx">angular</span><span class="p">.</span><span class="nx">module</span><span class="p">(</span><span class="s1">&#39;ldApp&#39;</span><span class="p">).</span><span class="nx">factory</span><span class="p">(</span><span class="s1">&#39;DataDisassembly&#39;</span><span class="p">,[</span><span class="s1">&#39;$rootScope&#39;</span><span class="p">,</span><span class="s1">&#39;command&#39;</span><span class="p">,</span><span class="s1">&#39;DataDisassemblyParsers&#39;</span><span class="p">,</span>
                                <span class="kd">function</span><span class="p">(</span><span class="nx">$rootScope</span><span class="p">,</span><span class="nx">command</span><span class="p">,</span><span class="nx">dataParsers</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">disassemblyData</span><span class="o">=</span><span class="p">{};</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>variable parsers is put there to make writing shorter <br />
it is a collection of functions for parsing output of 
utilities that do the work 
* </p></div></div><div class="code"><div class="wrapper">  <span class="kd">var</span> <span class="nx">parsers</span><span class="o">=</span><span class="nx">dataParsers</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>this command gets elf and program headers</p></div></div><div class="code"><div class="wrapper">  <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">getFileHeaders</span><span class="o">=</span><span class="kd">function</span><span class="p">(</span><span class="nx">file</span><span class="p">){</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get file headers</p></div></div><div class="code"><div class="wrapper">    <span class="kd">function</span> <span class="nx">fileHeadersC</span> <span class="p">(</span><span class="nx">data</span><span class="p">){</span>
      <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">fileHeaders</span><span class="o">=</span><span class="nx">parsers</span><span class="p">.</span><span class="nx">parseHeaders</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">command</span><span class="p">.</span><span class="nx">commandExecO</span><span class="p">({</span>
      <span class="nx">ptyPayload</span><span class="o">:</span><span class="s1">&#39;readelf -h -l &#39;</span> <span class="o">+</span> <span class="nx">file</span><span class="p">,</span>
      <span class="nx">callback</span><span class="o">:</span><span class="nx">fileHeadersC</span><span class="p">,</span>
      <span class="nx">msgType</span><span class="o">:</span><span class="s1">&#39;exec&#39;</span>
    <span class="p">});</span>
  <span class="p">};</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>sends command to invoke objdump to get headers
registers a callback that will call the parser function to parse output
and put everything in an array called sectionHeaders 
also calls function that will get hexdump and that is the last function
called when getting disassembly </p></div></div><div class="code"><div class="wrapper">  <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">getSectionHeaders</span><span class="o">=</span><span class="kd">function</span><span class="p">(</span><span class="nx">file</span><span class="p">){</span>
    <span class="kd">function</span> <span class="nx">sectionHeadersC</span> <span class="p">(</span><span class="nx">data</span><span class="p">){</span>
      <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">sectionHeaders</span><span class="o">=</span><span class="nx">parsers</span><span class="p">.</span><span class="nx">parseSHeaders</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>

      <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">getHexDump</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span><span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">sectionHeaders</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">command</span><span class="p">.</span><span class="nx">commandExecO</span><span class="p">({</span>
      <span class="nx">ptyPayload</span><span class="o">:</span><span class="s1">&#39;arm-linux-gnueabi-objdump -h &#39;</span> <span class="o">+</span> <span class="nx">file</span><span class="p">,</span>
      <span class="nx">callback</span><span class="o">:</span><span class="nx">sectionHeadersC</span><span class="p">,</span>
      <span class="nx">msgType</span><span class="o">:</span><span class="s1">&#39;exec&#39;</span>
    <span class="p">});</span>
  <span class="p">};</span></div></div></div><div class="segment"><div class="code"><div class="wrapper">  <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">getHeaders</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">file</span><span class="p">){</span>
    <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">getFileHeaders</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
    <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">getSectionHeaders</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
  <span class="p">};</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>get disassembly function</p></div></div><div class="code"><div class="wrapper">  <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">getSectionDisassembly</span><span class="o">=</span><span class="kd">function</span><span class="p">(</span><span class="nx">file</span><span class="p">){</span>
    <span class="nx">command</span><span class="p">.</span><span class="nx">commandExecO</span><span class="p">({</span>
      <span class="nx">callback</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">result</span><span class="p">){</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>parse result of a -D command</p></div></div><div class="code"><div class="wrapper">        <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">sectionData</span><span class="o">=</span><span class="nx">parsers</span><span class="p">.</span><span class="nx">processData</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
      <span class="p">},</span>
      <span class="nx">msgType</span><span class="o">:</span> <span class="s1">&#39;exec&#39;</span><span class="p">,</span>
      <span class="nx">ptyPayload</span><span class="o">:</span><span class="s1">&#39;arm-linux-gnueabi-objdump -D &#39;</span> <span class="o">+</span> <span class="nx">file</span>

    <span class="p">});</span>
  <span class="p">};</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>gets output of hex dump from readelf utility
and puts result in hexDump field of every section in sectionData array
since this is the last function called in getting disassembly 
it will call the doneLoading function
it it stops being last function than this will have to change</p></div></div><div class="code"><div class="wrapper">  <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">getHexDump</span><span class="o">=</span><span class="kd">function</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span><span class="nx">sectionHeaders</span><span class="p">){</span>
    <span class="nx">_</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">sectionHeaders</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span><span class="nx">i</span><span class="p">){</span>
      <span class="kd">function</span> <span class="nx">hd</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
        <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">sectionData</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">hexDump</span><span class="o">=</span><span class="nx">parsers</span><span class="p">.</span><span class="nx">parseXD</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s2">&quot;\n&quot;</span><span class="p">).</span><span class="nx">slice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">));</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">i</span><span class="o">==</span><span class="nx">sectionHeaders</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
          <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">doneLoading</span><span class="p">();</span> 
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="nx">command</span><span class="p">.</span><span class="nx">commandExecO</span><span class="p">({</span>
        <span class="nx">ptyPayload</span><span class="o">:</span><span class="s1">&#39;readelf -x &#39;</span><span class="o">+</span><span class="nx">v</span><span class="p">.</span><span class="nx">name</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="nx">file</span><span class="p">,</span>
        <span class="nx">callback</span><span class="o">:</span><span class="nx">hd</span><span class="p">,</span>
        <span class="nx">msgType</span><span class="o">:</span><span class="s1">&#39;exec&#39;</span>
      <span class="p">});</span>
    <span class="p">});</span>
 
  <span class="p">};</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>triggers event that signals that a view should be updated since
data arived</p></div></div><div class="code"><div class="wrapper">  <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">doneLoading</span><span class="o">=</span><span class="kd">function</span><span class="p">(){</span>
     <span class="nx">$rootScope</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s2">&quot;disassemblyDataLoaded&quot;</span><span class="p">,{</span>
      <span class="nx">disassemblyData</span><span class="o">:</span><span class="nx">disassemblyData</span>
    <span class="p">});</span>
  <span class="p">};</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>this function calls functions that get data from backend</p></div></div><div class="code"><div class="wrapper">  <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">disassemble</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">getSectionDisassembly</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
    <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">getHeaders</span><span class="p">(</span><span class="nx">file</span><span class="p">);</span>
  <span class="p">};</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>transforms command output recived from server into array of instructions</p></div></div><div class="code"><div class="wrapper">  <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">dissasemblyCallback</span><span class="o">=</span> <span class="kd">function</span> 
    <span class="nx">dissasemblyCallback</span><span class="p">(</span><span class="nx">disassemblyRaw</span><span class="p">){</span>
    
    <span class="kd">var</span> <span class="nx">dissasembly</span><span class="o">=</span> <span class="nx">disassemblyRaw</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">push</span><span class="p">([]);</span>
    <span class="kd">var</span> <span class="nx">basicBlocks</span><span class="o">=</span><span class="p">[];</span>
    <span class="nx">basicBlocks</span><span class="p">.</span><span class="nx">push</span><span class="p">([]);</span>

    <span class="kd">var</span> <span class="nx">disasArr</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">var</span> <span class="nx">disasObjArr</span> <span class="o">=</span> <span class="p">[];</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>bbBoundaryArr.push({from:0,to:0});</p></div></div><div class="code"><div class="wrapper">    <span class="kd">var</span> <span class="nx">boundaries</span><span class="o">=</span><span class="p">[];</span>
    <span class="kd">var</span> <span class="nx">branchPreviousInst</span><span class="o">=</span><span class="kc">false</span><span class="p">;</span>

    <span class="kd">var</span> <span class="nx">branchArray</span><span class="o">=</span><span class="p">[];</span>
    <span class="c1">//f or each disassembly line </span>
    <span class="nx">_</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">dissasembly</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>detects disassembly line with => in it</p></div></div><div class="code"><div class="wrapper">      <span class="kd">var</span> <span class="nx">disasLineCurrent</span><span class="o">=</span><span class="sr">/^\=\&gt;\s*(.*):\s+(\w+)([^;]*)(;(.*))?$/</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>detects line from gdb output</p></div></div><div class="code"><div class="wrapper">      <span class="kd">var</span> <span class="nx">disasLine</span><span class="o">=</span><span class="sr">/^\s*(.*):\s+(\w+)([^;]*)(;(.*))?$/</span><span class="p">;</span>

      <span class="kd">var</span> <span class="nx">splitedInstruction</span><span class="p">;</span>
      <span class="kd">var</span> <span class="nx">typeOfReg</span> <span class="p">;</span>
      <span class="kd">var</span> <span class="nx">instObj</span> <span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if line has =></p></div></div><div class="code"><div class="wrapper">      <span class="k">if</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">disasLineCurrent</span><span class="p">)){</span>
        <span class="nx">splitedInstruction</span> <span class="o">=</span>  <span class="nx">value</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="nx">disasLineCurrent</span><span class="p">);</span>
        <span class="nx">typeOfReg</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create object representing instruction</p></div></div><div class="code"><div class="wrapper">        <span class="nx">instObj</span> <span class="o">=</span><span class="p">{</span>
          <span class="nx">current</span><span class="o">:</span><span class="kc">true</span><span class="p">,</span>
          <span class="nx">address</span><span class="o">:</span> <span class="nx">splitedInstruction</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
          <span class="nx">opcode</span><span class="o">:</span>  <span class="nx">splitedInstruction</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
          <span class="nx">operands</span><span class="o">:</span><span class="nx">splitedInstruction</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
          <span class="nx">comment</span><span class="o">:</span> <span class="nx">splitedInstruction</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
        <span class="p">};</span>
      <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">disasLine</span><span class="p">)){</span>
        <span class="nx">splitedInstruction</span> <span class="o">=</span>  <span class="nx">value</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="nx">disasLine</span><span class="p">);</span>
        <span class="nx">typeOfReg</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>create object representing instruction</p></div></div><div class="code"><div class="wrapper">        <span class="nx">instObj</span> <span class="o">=</span><span class="p">{</span>
          <span class="nx">current</span><span class="o">:</span><span class="kc">false</span><span class="p">,</span>
          <span class="nx">address</span><span class="o">:</span> <span class="nx">splitedInstruction</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
          <span class="nx">opcode</span><span class="o">:</span>  <span class="nx">splitedInstruction</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
          <span class="nx">operands</span><span class="o">:</span><span class="nx">splitedInstruction</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
          <span class="nx">comment</span><span class="o">:</span> <span class="nx">splitedInstruction</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
          <span class="nx">uppperBoundary</span><span class="o">:</span><span class="kc">false</span><span class="p">,</span><span class="c1">// true if it is upper boundary of basic block</span>
          <span class="nx">downBoundary</span><span class="o">:</span><span class="kc">false</span><span class="p">,</span><span class="c1">// bottom boundary</span>
        <span class="p">};</span>
      <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if instructon detected</p></div></div><div class="code"><div class="wrapper">      <span class="k">if</span><span class="p">(</span><span class="nx">splitedInstruction</span><span class="p">){</span>
        <span class="nx">disasObjArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">instObj</span><span class="p">);</span>
      <span class="p">}</span>


    <span class="p">});</span>
   <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">disassembly</span><span class="o">=</span><span class="nx">disasObjArr</span><span class="p">;</span>
  <span class="p">};</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>return array of basic blocks from array of instructions</p></div></div><div class="code"><div class="wrapper">  <span class="nx">disassemblyData</span><span class="p">.</span><span class="nx">bbfd</span><span class="o">=</span><span class="kd">function</span> <span class="nx">basicBlocksFromDisassembly</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span>
    <span class="kd">var</span> <span class="nx">disassembly</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">push</span><span class="p">([]);</span>
    <span class="kd">var</span> <span class="nx">basicBlocks</span><span class="o">=</span><span class="p">[];</span>
    <span class="nx">basicBlocks</span><span class="p">.</span><span class="nx">push</span><span class="p">([]);</span>
    <span class="kd">var</span> <span class="nx">disasArr</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">var</span> <span class="nx">disasObjArr</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">var</span> <span class="nx">boundaries</span><span class="o">=</span><span class="p">[];</span>
    <span class="kd">var</span> <span class="nx">branchPreviousInst</span><span class="o">=</span><span class="kc">false</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">branchArray</span><span class="o">=</span><span class="p">[];</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>for each instruction </p></div></div><div class="code"><div class="wrapper">    <span class="nx">_</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">disassembly</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>check if last instruction in loop was branch</p></div></div><div class="code"><div class="wrapper">      <span class="k">if</span> <span class="p">(</span><span class="nx">branchPreviousInst</span><span class="p">){</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if so then mark this instruction as first in basic block</p></div></div><div class="code"><div class="wrapper">        <span class="nx">value</span><span class="p">.</span><span class="nx">uppperBoundary</span><span class="o">=</span><span class="kc">true</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>and push it in array of instructions that are boundaries of blocks</p></div></div><div class="code"><div class="wrapper">        <span class="nx">boundaries</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>set this indicator to false; following part sets it right</p></div></div><div class="code"><div class="wrapper">        <span class="nx">branchPreviousInst</span><span class="o">=</span><span class="kc">false</span><span class="p">;</span>
      <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>is it branch</p></div></div><div class="code"><div class="wrapper">      <span class="k">if</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">op</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/^b.*/</span><span class="p">)){</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if it is set indicator for next time</p></div></div><div class="code"><div class="wrapper">        <span class="nx">branchPreviousInst</span><span class="o">=</span><span class="kc">true</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if it is branch it means it is last in a  basic block</p></div></div><div class="code"><div class="wrapper">        <span class="nx">value</span><span class="p">.</span><span class="nx">bottomBoundary</span><span class="o">=</span><span class="kc">true</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>it is branch so put it in boundaries array</p></div></div><div class="code"><div class="wrapper">        <span class="nx">boundaries</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>and in special branch array to be used latter</p></div></div><div class="code"><div class="wrapper">        <span class="nx">branchArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
      <span class="p">}</span><span class="k">else</span><span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if it is first instruction mark it as boundary of block</p></div></div><div class="code"><div class="wrapper">        <span class="k">if</span><span class="p">(</span><span class="nx">boundaries</span><span class="p">.</span><span class="nx">length</span><span class="o">===</span><span class="mi">0</span><span class="p">){</span>
          <span class="nx">value</span><span class="p">.</span><span class="nx">uppperBoundary</span><span class="o">=</span><span class="kc">true</span><span class="p">;</span>
          <span class="nx">boundaries</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>push instruction in arrays</p></div></div><div class="code"><div class="wrapper">      <span class="nx">disasArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
      <span class="nx">disasObjArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">});</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>find instructions that are jumped on and put it in boundaries</p></div></div><div class="code"><div class="wrapper">    <span class="nx">_</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">branchArray</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span>
      <span class="kd">var</span> <span class="nx">elem</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">findWhere</span><span class="p">(</span><span class="nx">disasObjArr</span><span class="p">,{</span><span class="s1">&#39;address&#39;</span><span class="o">:</span><span class="p">(</span><span class="sr">/\s*(\w+).*/</span><span class="p">).</span><span class="nx">exec</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">operands</span><span class="p">)[</span><span class="mi">1</span><span class="p">]});</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">elem</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">indexDest</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">boundaries</span><span class="p">,</span><span class="nx">elem</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">indexDest</span><span class="o">===-</span><span class="mi">1</span><span class="p">){</span>
          <span class="nx">elem</span><span class="p">.</span><span class="nx">up</span><span class="o">=</span><span class="kc">true</span><span class="p">;</span>
          <span class="nx">boundaries</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">elem</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>

    <span class="p">});</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>sort boundaries by addresses this is needed because
maybe some are inserted in the last step</p></div></div><div class="code"><div class="wrapper">    <span class="kd">var</span> <span class="nx">boundariesSorted</span><span class="o">=</span><span class="nx">_</span><span class="p">.</span><span class="nx">sortBy</span><span class="p">(</span><span class="nx">boundaries</span><span class="p">,</span><span class="s1">&#39;address&#39;</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">boundaryArrC</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>now step trough each instruction and figure out 
should a new basic be made or should it be put in current one
algo goes instruction one by one while doing special work
when it encounters boundary of basic block</p></div></div><div class="code"><div class="wrapper">    <span class="nx">_</span><span class="p">.</span><span class="nx">each</span><span class="p">(</span><span class="nx">disasObjArr</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">){</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if current instruction is the boundary we did not processed</p></div></div><div class="code"><div class="wrapper">      <span class="k">if</span><span class="p">(</span><span class="nx">value</span><span class="o">===</span><span class="nx">boundariesSorted</span><span class="p">[</span><span class="nx">boundaryArrC</span><span class="p">]){</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>check to se if it is both upper and bottom boundary
which is the case when a branch is jumped on by
some other branch</p></div></div><div class="code"><div class="wrapper">        <span class="k">if</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">uppperBoundary</span> <span class="o">&amp;&amp;</span> <span class="nx">value</span><span class="p">.</span><span class="nx">bottomBoundary</span><span class="p">){</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>in that case just create new basic block put this one instruction </p></div></div><div class="code"><div class="wrapper">          <span class="nx">basicBlocks</span><span class="p">.</span><span class="nx">push</span><span class="p">([]);</span>
          <span class="nx">basicBlocks</span><span class="p">[</span><span class="nx">basicBlocks</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>and create new basic block</p></div></div><div class="code"><div class="wrapper">          <span class="nx">basicBlocks</span><span class="p">.</span><span class="nx">push</span><span class="p">([]);</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if just upper boundary and not upper and bottom</p></div></div><div class="code"><div class="wrapper">          <span class="k">if</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">uppperBoundary</span><span class="o">===</span><span class="kc">true</span><span class="p">){</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>this should check for edge case for like first block
to make algorithm easier
if upper boundary and last basic block not empty
create new basic block where instructions will be put</p></div></div><div class="code"><div class="wrapper">            <span class="k">if</span><span class="p">(</span><span class="nx">basicBlocks</span><span class="p">[</span><span class="nx">basicBlocks</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">length</span><span class="o">!==</span><span class="mi">0</span><span class="p">){</span>
              <span class="nx">basicBlocks</span><span class="p">.</span><span class="nx">push</span><span class="p">([]);</span>
            <span class="p">}</span>
            
            <span class="nx">basicBlocks</span><span class="p">[</span><span class="nx">basicBlocks</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>

          <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if bottom boundary push it in current basic block</p></div></div><div class="code"><div class="wrapper">          <span class="k">if</span><span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">bottomBoundary</span><span class="o">===</span><span class="kc">true</span><span class="p">){</span>
            <span class="nx">basicBlocks</span><span class="p">[</span><span class="nx">basicBlocks</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">}</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>increase counter that marks the boundary that is next to be 
processed</p></div></div><div class="code"><div class="wrapper">        
        <span class="nx">boundaryArrC</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>

      <span class="p">}</span><span class="k">else</span><span class="p">{</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>non boundary instructions just go in current basic block</p></div></div><div class="code"><div class="wrapper">        <span class="nx">basicBlocks</span><span class="p">[</span><span class="nx">basicBlocks</span><span class="p">.</span><span class="nx">length</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="nx">basicBlocks</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">return</span> <span class="nx">disassemblyData</span><span class="p">;</span>
<span class="p">}]);</span></div></div></div></div></body></html>